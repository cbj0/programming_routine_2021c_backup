# pre-热身赛 

本次练习不计成绩，大家放松去练习，不要有压力。

虽然不计成绩，但每一次练习都很重要，建议一定认真去练习，学习是自己的事情。

本次不练习，下次计成绩的练习可能就不会了。

大家需要尽快熟悉OJ平台的评测结果。

## 题目列表

- A 4191 helloworld
- B 4187 佛像
- C 4189 阿瓦隆卡牌
- D 4182 返航小统计
- E 4194 PHP是最好的语言
- F 4197 单节得分王
- G 4196 刀客塔的烦恼
- H 4199 二进制逆序
- I 4185 数列级数
- J 4188 数数入门
- K 4195 cbj学数学分析
- L 4183 女神的生日
- M 4192 正反相加
- N 4193 真•简单的a+b
- O 4190 忍蛙的圆形轨迹
- P 4184 YourSQL2.0
- Q 4198 基础物理实验 2（简单版）

## 部分题解

一些过于简单的题目无需写题解，直接阅读标准代码即可。

一些困难题目还是希望同学们勤思考。题解仅供参考。

### A 4191 helloworld

签到题。略。

### B 4187 佛像

本题考察字符画输出。这是历年考试必考的内容，必会必过，上机时请自行锻炼找BUG。

只需要转义反斜杠以及双引号即可通过。

### C 4189 阿瓦隆卡牌

### D 4182 返航小统计

### E 4194 PHP是最好的语言

### F 4197 单节得分王

### G 4196 刀客塔的烦恼

### H 4199 二进制逆序

### I 4185 数列级数

#### 示例代码

本题主要考察循环以及数据类型之间的转换，以下为标程

```C
#include <stdio.h>
int main(void)
{
    int q, m, k;
    double sum = 1.0;

    scanf("%d", &q);
    while (q--)
    {
        sum = 1.0, m = 1;
        scanf("%d", &k);
        
        while (sum <= k)
        {
            m++;
            sum += 1.0 / m;
        }
        printf("%d\n", m);
    }

    return 0;
}
```

#### 另一种解法

本题查一下OEIS就可以打表。当然，上机与考试时禁止查OEIS。[OEIS:A002387](http://oeis.org/A002387)

如果打表的话，例如写成这样：

```C
#include<stdio.h>

long long ans[30];

void init()
{
	ans[0]=1;
	ans[1]=2;
	ans[2]=4;
	ans[3]=11;
	ans[4]=31;
	ans[5]=83;
	ans[6]=227;
	ans[7]=616;
	ans[8]=1674;
	ans[9]=4550;
	ans[10]=12367;
	ans[11]=33617;
	ans[12]=91380;
	ans[13]=248397;
	ans[14]=675214;
	ans[15]=1835421;
	ans[16]=4989191;
	ans[17]=13562027;
	ans[18]=36865412;
	ans[19]=100210581;
	ans[20]=272400600;
	ans[21]=740461601;
	ans[22]=2012783315;
	ans[23]=5471312310;
}

int main()
{
	init();
	int q;
	while(~scanf("%d",&q))
	{
		while(q--)
		{
			int k;
			scanf("%d",&k);
			printf("%lld\n",ans[k]);
		}
	}
}
```

仅供参考。同样地，Q题“基础物理实验2”数据范围只有30，只要你能找到全体答案，当然也可以打表。

然而，打表是一种很糟糕的写法，仅在迫不得已的情形，或者数据量非常小的情形，才会考虑使用。本题的正规写法参见标准程序。

### J 4188 数数入门

### K 4195 cbj学数学分析

### L 4183 女神的生日

#### 示例代码

本题考察的是结构体的使用以及排序

```C
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
struct sb{
    char name[24];
    int y,m,d;
}a[120],b[1];//b数值用来交换
int main()
{
    int i,j,n,m,k;
    scanf("%d",&n);
    for (i=0;i<n;i++) scanf("%s %d %d %d",a[i].name,&a[i].y,&a[i].m,&a[i].d);
    for (i=0;i<n-1;i++)
         for (j=i+1;j<n;j++)
         {
             if ((a[i].y>a[j].y) || (a[i].y==a[j].y && a[i].m>a[j].m) || (a[i].y==a[j].y && a[i].m==a[j].m && a[i].d>=a[j].d))    //岁数大就交换到前面去，注意是a[i].d>=a[j].d而不是a[i].d>a[j].d，因为题目上说年龄相等，后输入的先输出
            {
                b[0]=a[i];
                a[i]=a[j];
                a[j]=b[0];//交换
            }
        }
    for (i=0;i<n;i++) printf("%s\n",a[i].name);
    return 0;
}

```

仅供参考。同样的，D题“返航小统计”可以和本题一样使用结构体，只需要加一步计数即可。

### M 4192 正反相加

#### 题目分析

这道题不需要复杂的数学操作，只考查了字符串相关函数的简单使用，其中反读数需要将字符串倒置，可以自行编写函数来操作，然后逐个位数相加进位即可。需要注意的是，输入的数字不超过100位并不意味着相加的结果不超过100位。用字符串模拟高精度数加法的思想在后续题目中也会有所体现。

#### 示例代码

```C
#include <stdio.h>
#include <string.h>

char ch1[101]={};
char ch2[101]={};
char ch3[102]={};					 //三个全局变量，ch1为读入数，ch2为倒置，ch3为计算结果

void reverse(void)						//将ch1倒置的函数
{
	int len = strlen(ch1);
	int i;
	for(i = 0;i < len;i++)
		ch2[i] = ch1[len-1-i];
}
int main()
{
	int i,add = 0;
	
	gets(ch1);
	
	int len = strlen(ch1);
	reverse();
	for(i = len-1;i >= 0;i--){
		if(ch1[i]+ch2[i]+add-2*'0'>=10)			//这里的分情况讨论是为了进位
			ch3[len-1-i] = ch1[i]+ch2[i]+add-'0'-10,add = 1;
		else
			ch3[len-1-i] = ch1[i]+ch2[i]+add-'0',add = 0;
	}
	if(add)
		ch3[len] = '1';				//如果最后一位可以进位上来，那么位数增加，最高位为1
	
	int len2 = strlen(ch3);
	
	for(i=len2-1;i>=0;i--)
		printf("%c",ch3[i]);		//倒序相加再倒序打印，可以方便最后一位的进位
		
	return 0;
}
```
### N 4193 真•简单的a+b

### O 4190 忍蛙的圆形轨迹

#### 题目分析

本题的原型为Nowcoder 2020 多校 2-B Boundary。原题允许使用各种语言，例如C++、Java、Python等等，也允许用C，当然允许C89。

本题只允许用C89。作为整场比赛的压轴题，难度最高。

本题的含义，即求解 **全体过原点的圆当中，经过给定点最多的圆上，给定点数是多少** 。

#### 核心算法

标程采用了**初等几何**的做法：圆周角定理，固定端点，跑顶点，统计角的众数。

_当然有用到较高几何知识的巧妙做法。这超纲了，只需要知道最简单的做法就行_ 

**统计众数**这种事情，可以采用这种办法：**先排序**，然后对数组**只跑一遍**，统计连续相同数的最大值。 

如果你懂C++，会容易想到C++STL中的map。这也超纲了，对于本课而言，不需要知道map。本题是一种退而求其次的办法。

<center>_但是远远没完。问题还多得很_</center>

#### 实现细节

##### 圆的问题

- 1. 固定端点，跑顶点的角，即使相等，也未必证明它们就在同一个圆上。

这点说的完全没错。这是整个算法需要谨慎考虑的一点，否则算法自然会失效。

解决办法，是用**叉乘**来检验，使得固定端点后，要跑的顶点全在一个半平面内。

为什么？试想，对于一个圆上的整点，个数自然有限，那么原点的右边自然存在一个相邻点。统计这个圆的时候，用原点和它右边的相邻点做端点就足够了。

##### eps的问题

- 2. 题中Hint说，“如果用到开平方，eps取1e-14”是什么意思？

是这样的。我们要用什么来表示这个角？难道说，要直接把角度求出来吗？

如果要求角，一定要用到反三角函数。而这显然不是必要的。我们想对角排序，无需对具体得角度排序，只需要对**余弦**排序就足够了，因为余弦方便计算。（正弦、正切等相对不容易计算。）

高中学过，余弦的计算方法有两种：向量内积除以向量模长、余弦定理。两种办法是**等价的**，用哪个都一样。都需要在分母的位置开平方。

我们的点都是整点，本来不会出现精度问题，但是开平方，就会出现精度问题。

一种解决办法，是直接对**余弦的平方**排序，钝角时要记得乘个负号保证单调性。在计算的时候，就避开了开平方，这样就根本没有eps问题。当然，为了让代码便于理解，暂时不介绍这种做法。

另一种解决办法，是使用eps。在上文“统计连续相同数的最大值”的地方，希望连续相同数**区间的两个端点**，相差不超过eps。因为它们代表的是同一个圆周角，两头之间不能超过eps。

提醒：不可以在qsort比较函数compare里面使用eps，下文还会提到。

本题的数据量很大，而开一次平方的误差不大，因此eps需要尽可能小。一般情况下，double完全保证的有效数字最高是15位。（对于较小的数能更精确。）如果你对代码没有信心，可以把eps改得更小一些试试看。

##### 比较函数的问题

- 3. C里面，较快的排序只能用qsort。它的比较函数有没有讲究？

非常重要。

对于本题而言，比较函数老老实实按照规范形式写。即：

大于返回1（正数），小于返回-1（负数），**等于返回0**。

请务必这样写，并且，**千万不要在比较函数里面写eps**。对于qsort而言，这一定会造成排序没做好。我们需要排序完全做好。

C语言的qsort函数，就是简单的**快速排序算法**，具体的算法内容是数据结构课、算法课的内容，超纲，不需要了解。但你需要知道，比较函数compare就是qsort的评判标准，快速排序的执行过程比较杂乱，引入eps非常容易造成混乱。尤其是在后文还要找连续区间相等，不停判断区间端点的时候，排序没有做好是致命的。

##### 连续区间的问题

- 4. 如何只跑一遍求“连续区间数值相等”？

首先，确保之前的排序已经做好了，即严格排序已经完成了。

我们引入两个游标，一个左游标，一个右游标。然后从数组的最左边开始往右跑。

先固定一个左游标，然后令右游标为左游标，检查二者是否相等。如果相等，就将右游标向右移动，继续上述检查。如果不相等，则停止，处理其他内容，例如区间长等等。处理完了之后，再更新左游标为刚才的右游标，重复操作，直到左游标或右游标跑到数组右端为止。

在有eps的情况下，检查左右游标所在的值，距离是否超过eps，即区间的两个端点涵盖的取值范围是否超过eps。

#### 具体代码

具体代码等到比赛结束，或者有人做出来之后，再放出来吧。

### Q 4198 基础物理实验 2（简单版）

本题仍然可以打表输出。比如，你继续去OEIS上查。但是，只能查到整数部分、部分分母以及假分数的分子，带分数的分子查不到，并且分母的28到30也查不到。于是你需要在草稿纸上暴力手算，至多加一个计算器算，算到地老天荒。比如，2小时后，你终于算完了，抄到代码里面。此时若是一不小心抄错，比如抄乱了两个数，就会一直WA，WA到怀疑人生。

（这可能是某位助教的打表经历）

打表的做法，在比赛结束之后放上来。因为，如果直接放上来，相当于直接把这么复杂的答案告诉各位了，这题就失掉了趣味。